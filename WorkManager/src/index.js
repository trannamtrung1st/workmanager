import "react-native-gesture-handler";
import React, { useState, useEffect } from "react";
import { NavigationContainer } from "@react-navigation/native";
import { AppDrawerNavigator } from "$navigation";
import { AuthContext } from "$app-contexts";
import { Login } from "$views";
import { UserApi, NotiApi } from "$api";
import { G } from "$global";
import messaging from "@react-native-firebase/messaging";
import AsyncStorage from "@react-native-community/async-storage";
import PushNotification from "react-native-push-notification";

let logoutIntervalId;
export default function App() {
  useEffect(() => {
    PushNotification.popInitialNotification(notification => {
      NotiApi.handleNotification(notification);
    });

    //foreground handler
    const unsubscribe = messaging().onMessage(async remoteMessage => {
      console.log("FCM Message Data:", remoteMessage.data);

      const data = remoteMessage.data;

      // Update a users messages list using AsyncStorage
      // const currentMessages = await AsyncStorage.getItem("messages");
      // const messageArray = JSON.parse(currentMessages) ?? [];
      // messageArray.push(remoteMessage.data);
      // await AsyncStorage.setItem("messages", JSON.stringify(messageArray));

      PushNotification.localNotification({
        /* Android Only Properties */
        // id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
        // ticker: "My Notification Ticker", // (optional)
        // autoCancel: true, // (optional) default: true
        // largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
        // smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
        // bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
        // subText: "This is a subText", // (optional) default: none
        // color: "red", // (optional) default: system default
        // vibrate: true, // (optional) default: true
        // vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
        // tag: 'some_tag', // (optional) add tag to message
        // group: "group", // (optional) add group to message
        // ongoing: false, // (optional) set whether this is an "ongoing" notification
        // priority: "high", // (optional) set notification priority, default: high
        // visibility: "private", // (optional) set notification visibility, default: private
        // importance: "high", // (optional) set notification importance, default: high

        /* iOS and Android properties */
        // title: "Some message babe <3", // (optional)
        // message: "My Notification Message" // (required)
        ...data
        // playSound: false, // (optional) default: true
        // soundName: "default", // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
        // number: "10", // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
        // repeatType: "day", // (optional) Repeating interval. Check 'Repeating Notifications' section for more info.
        // actions: '["Yes", "No"]' // (Android only) See the doc for notification actions to know more
      });
    });
    return unsubscribe;
  }, []);

  const [authContext, setAuthContext] = useState(reset());
  if (!G.tokenGot) {
    G.tokenGot = true;
    UserApi.getTokenThen(token => {
      G.tokenModel = JSON.parse(token);
      const context = reset();
      setAuthContext(context);
    });
    return null;
  }

  function reset() {
    return {
      accessToken: G.tokenModel?.access_token,
      expiresUtc: G.tokenModel?.expires_utc,
      username: G.tokenModel?.username,
      employeeCode: G.tokenModel?.employee_code,
      role: G.tokenModel?.role,
      userId: G.tokenModel?.user_id,
      logoutIntervalSet: false,
      login,
      logout
    };
  }

  function logout() {
    if (logoutIntervalId) clearInterval(logoutIntervalId);
    UserApi.logout(err => {
      if (err) return;
      G.tokenModel = null;
      setAuthContext(reset());
    });
  }

  function login(tokenModel) {
    UserApi.saveToken(tokenModel, () => {
      G.tokenModel = tokenModel;
      setAuthContext(reset());
    });
  }

  if (!authContext.logoutIntervalSet && authContext.accessToken) {
    authContext.logoutIntervalSet = true;
    logoutIntervalId = setInterval(() => {
      if (authContext.expiresUtc <= new Date()) {
        logout();
      }
    }, 60000);
  }

  console.log(G.tokenModel?.user_id);
  return (
    <AuthContext.Provider value={authContext}>
      {authContext.accessToken ? (
        <NavigationContainer>
          <AppDrawerNavigator />
        </NavigationContainer>
      ) : (
        <Login />
      )}
    </AuthContext.Provider>
  );
}
